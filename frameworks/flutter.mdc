---
description: 
globs: 
alwaysApply: false
---
---
description: This rule explains the best practices for Flutter widget patterns and cross-platform mobile development.
globs: **/*.dart
alwaysApply: false
---

# Flutter Rules

- For UI components without internal state, use StatelessWidget.
- For components that need to maintain state, use StatefulWidget:

```dart
class Counter extends StatefulWidget {
  @override
  _CounterState createState() => _CounterState();
}

class _CounterState extends State<Counter> {
  int _count = 0;
  
  void _increment() {
    setState(() { _count++; });
  }
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Count: $_count'),
        ElevatedButton(onPressed: _increment, child: Text('Increment')),
      ],
    );
  }
}
```

- For complex applications, use state management solutions (Provider, Bloc, Riverpod).
- Use appropriate folder structure to organize code (models, screens, widgets, services).
- Use named routes and Navigator.pushNamed() for navigation.
- Use async/await for handling asynchronous operations and appropriate error handling.
- Use themes (themes) to maintain consistent styles across the application. 